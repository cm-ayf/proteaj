package proteaj.codegen.lazy;

import proteaj.ir.*;
import proteaj.tast.*;
import proteaj.tast.util.*;
import proteaj.util.*;

import javassist.*;
import java.util.*;

public class ProgramTranslator extends TreeTranslator {
  public ProgramTranslator(ClassDeclaration clazz, List<ClassDeclaration> generated, Map<IROperator, Pair<CtMethod, Map<Integer, CtMethod>>> methods) {
    this.clazz = clazz.clazz;
    this.filePath = clazz.filePath;
    this.generated = generated;
    this.methods = methods;
  }

  @Override
  public Expression translate(Operation operation) {
    if (methods.containsKey(operation.operator)) {
      Pair<CtMethod, Map<Integer, CtMethod>> pair = methods.get(operation.operator);
      CtMethod method = pair._1;
      Map<Integer, CtMethod> lazyMap = pair._2;

      List<Expression> operands = new ArrayList<Expression>();

      for (int i = 0; i < operation.operands.size(); i++) {
        if (lazyMap.containsKey(i)) try {
          CtMethod iMethod = lazyMap.get(i);
          CtClass sup = iMethod.getDeclaringClass();
          Expression e = operation.operands.get(i);
          Set<Expression> locals = LocalCollector.collectLocals(e);

          CtClass thunk = clazz.makeNestedClass("ProteaJAutoGeneratedClass" + i, true);
          thunk.setSuperclass(sup);

          List<CtClass> params = new ArrayList<CtClass>();
          List<Expression> args = new ArrayList<Expression>();

          for (Expression local : locals) {
            params.add(local.type);
            args.add(local);
          }

          CtConstructor constructor = new CtConstructor(params.toArray(new CtClass[params.size()]), thunk);
          thunk.addConstructor(constructor);

          Block block = new Block();
          ThisExpression thisExpr = new ThisExpression(thunk);

          List<CtField> fields = new ArrayList<>();
          Map<Expression, FieldAccess> map = new HashMap<Expression, FieldAccess>();

          for (int n = 0; n < params.size(); n++) {
            CtClass type = params.get(n);
            CtField field = new CtField(type, "field" + n, thunk);
            thunk.addField(field);
            fields.add(field);

            FieldAccess access = new FieldAccess(thisExpr, field);
            AssignExpression assign = new AssignExpression(access, new ParamAccess(field.getName(), type, n));

            map.put(args.get(n), access);
            block.addStatement(new ExpressionStatement(assign));
          }

          ConstructorBody body = new ConstructorBody(block);
          ConstructorDeclaration constructorDeclaration = new ConstructorDeclaration(constructor, body);

          CtMethod eval = new CtMethod(iMethod.getReturnType(), "eval", new CtClass[0], thunk);
          thunk.addMethod(eval);
          thunk.setModifiers(Modifiers.PUBLIC);

          ThunkBodyTranslator translator = new ThunkBodyTranslator(map);
          ReturnStatement returnStatement = new ReturnStatement(translator.translate(e));
          Block mBlock = new Block();
          mBlock.addStatement(returnStatement);
          MethodBody mBody = new MethodBody(mBlock);
          MethodDeclaration methodDeclaration = new MethodDeclaration(eval, mBody);

          ClassDeclaration classDeclaration = new ClassDeclaration(thunk, filePath, fields);
          classDeclaration.addConstructor(constructorDeclaration);
          classDeclaration.addMethod(methodDeclaration);

          generated.add(classDeclaration);

          operands.add(new NewExpression(constructor, args));
        } catch (NotFoundException | CannotCompileException e) {
          assert false;
          throw new RuntimeException(e);
        }
        else operands.add(operation.operands.get(i));
      }

      try { return new StaticMethodCall(method, operands); }
      catch (NotFoundException e) {
        assert false;
        throw new RuntimeException(e);
      }
    }

    return operation;
  }


  private final CtClass clazz;
  private final String filePath;
  private final List<ClassDeclaration> generated;
  private final Map<IROperator, Pair<CtMethod, Map<Integer, CtMethod>>> methods;
}
